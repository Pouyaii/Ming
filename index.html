<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ming Dynasty Immersive Museum</title>
    <link rel="icon" type="image/png" href="Seal_of_Ming_dynasty.svg.png">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Times New Roman', serif;
            background-color: #000;
            touch-action: none;
        }
        #instructions {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            color: #FFD840;
            z-index: 10;
            text-align: center;
            cursor: pointer;
            transition: opacity 0.5s;
            padding: 16px;
            box-sizing: border-box;
        }
        #program-logo {
            width: 120px;
            height: auto;
            margin-bottom: 20px;
            opacity: 0.9;
        }
        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            letter-spacing: 5px;
            text-transform: uppercase;
            border-bottom: 2px solid #FFD840;
            padding-bottom: 20px;
        }
        p {
            font-size: 1.2rem;
            color: #ccc;
        }
        .controls {
            margin-top: 20px;
            font-size: 1rem;
            color: #888;
            border: 1px solid #444;
            padding: 15px;
            border-radius: 5px;
        }
        #touch-ui {
            position: fixed;
            inset: 0;
            z-index: 15;
            pointer-events: none;
            display: none;
        }
        #move-joystick {
            position: absolute;
            left: 28px;
            bottom: 28px;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            border: 2px solid rgba(255, 216, 64, 0.9);
            background: rgba(0, 0, 0, 0.35);
            box-shadow: 0 0 18px rgba(0, 0, 0, 0.5) inset;
            pointer-events: auto;
            touch-action: none;
        }
        #move-knob {
            position: absolute;
            width: 64px;
            height: 64px;
            left: calc(50% - 32px);
            top: calc(50% - 32px);
            border-radius: 50%;
            border: 2px solid rgba(255, 216, 64, 0.95);
            background: rgba(255, 216, 64, 0.28);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.35);
        }
        #touch-look-zone {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 60vw;
            height: 62vh;
            pointer-events: auto;
            touch-action: none;
        }
        #touch-hint {
            position: absolute;
            right: 20px;
            bottom: 24px;
            color: rgba(255, 255, 255, 0.72);
            font-size: 0.85rem;
            border: 1px solid rgba(255, 255, 255, 0.22);
            border-radius: 999px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.35);
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.6s ease;
        }
        #touch-hint.fade-out {
            opacity: 0;
        }
        @media (max-width: 820px), (pointer: coarse) {
            h1 {
                font-size: 2rem;
                letter-spacing: 2px;
            }
            p {
                font-size: 1rem;
            }
            .controls {
                font-size: 0.95rem;
                padding: 12px;
            }
        }
        #loading {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #fff;
            font-family: monospace;
            pointer-events: none;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
        }
        #dev-toolkit {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            padding: 14px;
            color: #f2f2f2;
            background: rgba(0, 0, 0, 0.88);
            border: 1px solid #3f3f3f;
            border-radius: 8px;
            z-index: 20;
            display: none;
            box-shadow: 0 10px 22px rgba(0, 0, 0, 0.4);
            font-family: Arial, sans-serif;
        }
        #dev-toolkit h2 {
            margin: 0 0 12px;
            font-size: 1.1rem;
            color: #FFD840;
        }
        #dev-toolkit .dev-row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }
        #dev-toolkit .group-title {
            margin: 12px 0 6px;
            font-size: 0.9rem;
            color: #FFD840;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }
        #dev-toolkit input,
        #dev-toolkit select {
            width: 100%;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 6px;
            font-size: 0.86rem;
            background: #151515;
            color: #f2f2f2;
        }
        #dev-toolkit code {
            color: #9dc8ff;
            font-size: 0.8rem;
            background: #111;
            border: 1px solid #444;
            padding: 1px 4px;
            border-radius: 4px;
        }
        #dev-toolkit .hint {
            margin: 0 0 10px;
            font-size: 0.8rem;
            color: #bdbdbd;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="instructions">
        <img id="program-logo" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Seal_of_Ming_dynasty.svg/960px-Seal_of_Ming_dynasty.svg.png" alt="Ming Seal">
        <h1>The Ming Hall</h1>
        <p>Click anywhere to Enter</p>
        <div class="controls">
            <b>WASD</b> to Move<br>
            <b>MOUSE</b> to Look<br>
            <b>ESC</b> to Pause
        </div>
    </div>

    <div id="touch-ui" aria-hidden="true">
        <div id="move-joystick">
            <div id="move-knob"></div>
        </div>
        <div id="touch-look-zone"></div>
        <div id="touch-hint">Touch right side to look around</div>
    </div>

    <div id="loading">Loading Assets...</div>

    <div id="dev-toolkit">
        <h2>3D Artifact Dev Tools</h2>
        <p class="hint">Toggle with hidden key <code>I</code>. Values are live and editable.</p>
        <div class="dev-row">
            <label for="dev-artifact-select">Artifact</label>
            <select id="dev-artifact-select">
                <option value="north">North (Statue)</option>
                <option value="south">South (Pot)</option>
                <option value="east">East (Golden)</option>
                <option value="west">West (Bowl)</option>
            </select>
        </div>

        <div class="group-title">Position</div>
        <div class="dev-row"><label for="dev-pos-x">X</label><input id="dev-pos-x" type="number" step="0.01"></div>
        <div class="dev-row"><label for="dev-pos-y">Y</label><input id="dev-pos-y" type="number" step="0.01"></div>
        <div class="dev-row"><label for="dev-pos-z">Z</label><input id="dev-pos-z" type="number" step="0.01"></div>

        <div class="group-title">Scale</div>
        <div class="dev-row"><label for="dev-scale-uniform">Uniform</label><input id="dev-scale-uniform" type="checkbox" checked></div>
        <div class="dev-row"><label for="dev-scale-x">X</label><input id="dev-scale-x" type="number" step="0.01" min="0.01"></div>
        <div class="dev-row"><label for="dev-scale-y">Y</label><input id="dev-scale-y" type="number" step="0.01" min="0.01"></div>
        <div class="dev-row"><label for="dev-scale-z">Z</label><input id="dev-scale-z" type="number" step="0.01" min="0.01"></div>

        <div class="group-title">Rotation (radians)</div>
        <div class="dev-row"><label for="dev-rot-x">X</label><input id="dev-rot-x" type="number" step="0.01"></div>
        <div class="dev-row"><label for="dev-rot-y">Y</label><input id="dev-rot-y" type="number" step="0.01"></div>
        <div class="dev-row"><label for="dev-rot-z">Z</label><input id="dev-rot-z" type="number" step="0.01"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Custom PointerLockControls ---
        const _vector = new THREE.Vector3();
        const _euler = new THREE.Euler( 0, 0, 0, 'YXZ' );
        const _PI_2 = Math.PI / 2;

        class PointerLockControls extends THREE.EventDispatcher {
            constructor( camera, domElement ) {
                super();
                this.camera = camera;
                this.domElement = domElement;
                this.isLocked = false;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                this.pointerSpeed = 1.0;

                this._onMouseMove = this.onMouseMove.bind( this );
                this._onPointerlockChange = this.onPointerlockChange.bind( this );
                this._onPointerlockError = this.onPointerlockError.bind( this );

                this.connect();
            }

            connect() {
                this.domElement.ownerDocument.addEventListener( 'mousemove', this._onMouseMove );
                this.domElement.ownerDocument.addEventListener( 'pointerlockchange', this._onPointerlockChange );
                this.domElement.ownerDocument.addEventListener( 'pointerlockerror', this._onPointerlockError );
            }

            disconnect() {
                this.domElement.ownerDocument.removeEventListener( 'mousemove', this._onMouseMove );
                this.domElement.ownerDocument.removeEventListener( 'pointerlockchange', this._onPointerlockChange );
                this.domElement.ownerDocument.removeEventListener( 'pointerlockerror', this._onPointerlockError );
            }

            lock() {
                try {
                    const promise = this.domElement.requestPointerLock();
                    if (promise && typeof promise.catch === 'function') {
                        promise.catch((err) => {
                            console.warn("PointerLock request failed:", err);
                        });
                    }
                } catch (e) {
                    console.warn("PointerLock sync error:", e);
                }
            }

            unlock() {
                this.domElement.ownerDocument.exitPointerLock();
            }

            onMouseMove( event ) {
                if ( this.isLocked === false ) return;
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                if ( Math.abs(movementX) > 100 || Math.abs(movementY) > 100 ) return;
                _euler.setFromQuaternion( this.camera.quaternion );
                _euler.y -= movementX * 0.002 * this.pointerSpeed;
                _euler.x -= movementY * 0.002 * this.pointerSpeed;
                _euler.x = Math.max( _PI_2 - this.maxPolarAngle, Math.min( _PI_2 - this.minPolarAngle, _euler.x ) );
                this.camera.quaternion.setFromEuler( _euler );
                this.dispatchEvent( { type: 'change' } );
            }

            onPointerlockChange() {
                if ( this.domElement.ownerDocument.pointerLockElement === this.domElement ) {
                    this.dispatchEvent( { type: 'lock' } );
                    this.isLocked = true;
                } else {
                    this.dispatchEvent( { type: 'unlock' } );
                    this.isLocked = false;
                }
            }

            onPointerlockError() {
                console.warn( 'PointerLockControls: Unable to use Pointer Lock API' );
            }

            getObject() { return this.camera; }
            moveRight( distance ) {
                _vector.setFromMatrixColumn( this.camera.matrix, 0 );
                this.camera.position.addScaledVector( _vector, distance );
            }
            moveForward( distance ) {
                _vector.setFromMatrixColumn( this.camera.matrix, 0 );
                _vector.crossVectors( this.camera.up, _vector );
                this.camera.position.addScaledVector( _vector, distance );
            }
        }

        // --- Configuration ---
        const ROOM_WIDTH = 50;
        const ROOM_DEPTH = 50;
        const ROOM_HEIGHT = 16;
        const WALL_THICKNESS = 1;

        // Physics
        const STAND_HEIGHT = 1.7;
        const CROUCH_HEIGHT = 1.0;
        const PLAYER_SPEED = 10.0;
        const SPRINT_SPEED = 18.0;
        const CROUCH_SPEED = 4.0;
        const GRAVITY = 300.0;
        const JUMP_FORCE = 37.5;

        // Colors
        const COL_IMPERIAL_RED = 0x9B1B30;
        const COL_GOLD = 0xFFD840; // Vibrant Ming Gold
        const COL_MING_BLUE = 0x102E4A; // Lapiz/Cobalt
        const COL_DARK_WOOD = 0x3F2A14;
        const COL_WALL = 0xAA3333;

        // Assets
        const LOGO_URL = 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Ming_dynasty_%28Chinese_characters%29.svg/2560px-Ming_dynasty_%28Chinese_characters%29.svg.png';
        const LONG_PAINTING_URL = 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/13/%E5%8D%97%E9%83%BD%E7%B9%81%E6%9C%83%E5%9C%96_01.jpg/2560px-%E5%8D%97%E9%83%BD%E7%B9%81%E6%9C%83%E5%9C%96_01.jpg';

        const PAINTINGS = [
            { url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/A_Seated_Portrait_of_Ming_Emperor_Taizu.jpg/960px-A_Seated_Portrait_of_Ming_Emperor_Taizu.jpg', title: 'Emperor Taizu' },
            { url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Ch%27iu_Ying_001.jpg/1280px-Ch%27iu_Ying_001.jpg', title: 'Chiu Ying' },
            { url: 'https://upload.wikimedia.org/wikipedia/commons/0/0f/Portrait_of_Jiang_Shunfu.jpg', title: 'Jiang Shunfu' },
            { url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Portrait_assis_de_l%27empereur_Ming_Chengzu.jpg/960px-Portrait_assis_de_l%27empereur_Ming_Chengzu.jpg', title: 'Emperor Chengzu' },
            { url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Detail_of_The_Emperor%27s_Approach%2C_Xuande_period.jpg/960px-Detail_of_The_Emperor%27s_Approach%2C_Xuande_period.jpg', title: 'Emperors Approach' },
            { url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Ji_Sheng-Peddler.jpg/500px-Ji_Sheng-Peddler.jpg', title: 'Peddler' },
            { url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/d/d7/Chen_Hongshou%2C_leaf_album_painting.jpg/960px-Chen_Hongshou%2C_leaf_album_painting.jpg', title: 'Chen Hongshou' },
            { url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Lofty_Mt.Lu_by_Shen_Zhou.jpg/500px-Lofty_Mt.Lu_by_Shen_Zhou.jpg', title: 'Lofty Mt. Lu' },
            { url: 'https://upload.wikimedia.org/wikipedia/commons/3/33/Ming_Emperor_Xuande_playing_Golf.jpg', title: 'Xuande Playing Golf' }
        ];

        // --- Globals ---
        let camera, scene, renderer, controls;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let isSprinting = false;
        let isCrouching = false;

        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let loadingManager;

        const collidableObjects = [];
        const rotatingArtifacts = [];
        let artifactSpinEnabled = false;
        const artifactRegistry = {};
        const devToolkitState = {
            isVisible: false,
            selectedId: 'north',
            isUpdatingInputs: false
        };
        let devToolkitEl;
        let suppressInstructionsOverlay = false;
        let touchUiEl;
        const touchState = {
            isMobileOrTablet: false,
            movePointerId: null,
            lookPointerId: null,
            hasStartedLooking: false,
            joystickVector: new THREE.Vector2(0, 0),
            joystickCenter: new THREE.Vector2(0, 0),
            joystickRadius: 56,
            lookLast: new THREE.Vector2(0, 0)
        };
        const qualitySettings = {
            maxPixelRatio: 2,
            mainShadowMapSize: 1536,
            artifactShadowMapSize: 1024,
            enableArtifactSpotShadows: true,
            shouldUseAntialias: true
        };

        function getQualitySettings(isMobileOrTablet) {
            if (isMobileOrTablet) {
                return {
                    maxPixelRatio: 1.25,
                    mainShadowMapSize: 1024,
                    artifactShadowMapSize: 512,
                    enableArtifactSpotShadows: false,
                    shouldUseAntialias: false
                };
            }

            return {
                maxPixelRatio: 2,
                mainShadowMapSize: 1536,
                artifactShadowMapSize: 1024,
                enableArtifactSpotShadows: true,
                shouldUseAntialias: true
            };
        }

        init();
        animate();

        function init() {
            touchState.isMobileOrTablet = detectMobileOrTablet();
            Object.assign(qualitySettings, getQualitySettings(touchState.isMobileOrTablet));

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.Fog(0x111111, 10, 70);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = STAND_HEIGHT;

            renderer = new THREE.WebGLRenderer({
                antialias: qualitySettings.shouldUseAntialias,
                powerPreference: 'high-performance'
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, qualitySettings.maxPixelRatio));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = false;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.15;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            loadingManager = new THREE.LoadingManager();
            loadingManager.onLoad = function () {
                const loadingScreen = document.getElementById('loading');
                if (loadingScreen) loadingScreen.style.display = 'none';
            };
            loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
                const loadingScreen = document.getElementById('loading');
                if (loadingScreen) loadingScreen.innerText = `Loading Assets... ${Math.round((itemsLoaded / itemsTotal) * 100)}%`;
            };

            controls = new PointerLockControls(camera, document.body);
            initDevToolkit();
            applyDeviceSpecificInstructions(touchState.isMobileOrTablet);
            touchUiEl = document.getElementById('touch-ui');
            initTouchControls();

            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', function () {
                window.focus();
                if (!touchState.isMobileOrTablet) {
                    controls.lock();
                } else {
                    instructions.style.display = 'none';
                    controls.isLocked = true;
                    if (touchUiEl) touchUiEl.style.display = 'block';
                }
            });

            document.addEventListener('pointerlockerror', (event) => {
                if (!suppressInstructionsOverlay) {
                    instructions.style.display = 'flex';
                }
            });

            controls.addEventListener('lock', function () {
                instructions.style.display = 'none';
            });

            controls.addEventListener('unlock', function () {
                if (!suppressInstructionsOverlay) {
                    instructions.style.display = 'flex';
                }
                if (touchState.isMobileOrTablet && touchUiEl) touchUiEl.style.display = 'none';
            });

            scene.add(controls.getObject());

            if (touchState.isMobileOrTablet) {
                controls.isLocked = true;
            }

            const onKeyDown = function (event) {
                if (event.ctrlKey && ['KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(event.code)) {
                    event.preventDefault();
                }
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = true;
                        event.preventDefault();
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = true;
                        event.preventDefault();
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = true;
                        event.preventDefault();
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = true;
                        event.preventDefault();
                        break;
                    case 'Space':
                        if (canJump === true) velocity.y += JUMP_FORCE;
                        canJump = false;
                        event.preventDefault();
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        isSprinting = true;
                        event.preventDefault();
                        break;
                    case 'ControlLeft':
                        isCrouching = true;
                        event.preventDefault();
                        break;
                    case 'KeyH':
                        artifactSpinEnabled = !artifactSpinEnabled;
                        break;
                    case 'KeyI':
                        event.preventDefault();
                        toggleDevToolkit();
                        break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW':
                        moveForward = false;
                        event.preventDefault();
                        break;
                    case 'ArrowLeft':
                    case 'KeyA':
                        moveLeft = false;
                        event.preventDefault();
                        break;
                    case 'ArrowDown':
                    case 'KeyS':
                        moveBackward = false;
                        event.preventDefault();
                        break;
                    case 'ArrowRight':
                    case 'KeyD':
                        moveRight = false;
                        event.preventDefault();
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        isSprinting = false;
                        event.preventDefault();
                        break;
                    case 'ControlLeft':
                        isCrouching = false;
                        event.preventDefault();
                        break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            buildRoom();
            buildLighting();
            buildExhibitsAndArt();
            renderer.shadowMap.needsUpdate = true;

            window.addEventListener('resize', onWindowResize);
        }

        function detectMobileOrTablet() {
            const ua = navigator.userAgent || '';
            const touchCapable = navigator.maxTouchPoints > 0;
            const coarsePointer = window.matchMedia('(pointer: coarse)').matches;
            const mobileUA = /Android|iPhone|iPad|iPod|Mobile|Tablet|Silk|Kindle|PlayBook|IEMobile/i.test(ua);
            return mobileUA || (touchCapable && coarsePointer);
        }

        function applyDeviceSpecificInstructions(isTouchDevice) {
            const instructions = document.getElementById('instructions');
            const prompt = instructions.querySelector('p');
            const controlsText = instructions.querySelector('.controls');

            if (isTouchDevice) {
                prompt.textContent = 'Press anywhere to Enter';
                controlsText.innerHTML = '<b>Left Analog</b> to Move<br><b>Touch Right Side</b> to Look<br><b>Two Finger Tap</b> to Pause';
            } else {
                prompt.textContent = 'Click anywhere to Enter';
                controlsText.innerHTML = '<b>WASD</b> to Move<br><b>MOUSE</b> to Look<br><b>ESC</b> to Pause';
            }
        }

        function initTouchControls() {
            const touchUi = document.getElementById('touch-ui');
            if (!touchState.isMobileOrTablet || !touchUi) return;

            const joystick = document.getElementById('move-joystick');
            const knob = document.getElementById('move-knob');
            const lookZone = document.getElementById('touch-look-zone');
            const touchHint = document.getElementById('touch-hint');


            const updateJoystickCenter = () => {
                const rect = joystick.getBoundingClientRect();
                touchState.joystickCenter.set(rect.left + rect.width / 2, rect.top + rect.height / 2);
                touchState.joystickRadius = rect.width * 0.4;
            };
            updateJoystickCenter();

            const resetJoystick = () => {
                touchState.joystickVector.set(0, 0);
                moveForward = false;
                moveBackward = false;
                moveLeft = false;
                moveRight = false;
                knob.style.transform = 'translate(0px, 0px)';
            };

            const updateMovementFlagsFromJoystick = () => {
                const x = touchState.joystickVector.x;
                const y = touchState.joystickVector.y;
                const threshold = 0.15;
                moveLeft = x < -threshold;
                moveRight = x > threshold;
                moveForward = y < -threshold;
                moveBackward = y > threshold;
            };

            const updateJoystickFromTouch = (touch) => {
                const dx = touch.clientX - touchState.joystickCenter.x;
                const dy = touch.clientY - touchState.joystickCenter.y;
                const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                const clamped = Math.min(distance, touchState.joystickRadius);
                const nx = dx / distance;
                const ny = dy / distance;
                const vx = (nx * clamped) / touchState.joystickRadius;
                const vy = (ny * clamped) / touchState.joystickRadius;

                touchState.joystickVector.set(vx, vy);
                updateMovementFlagsFromJoystick();
                knob.style.transform = `translate(${(vx * touchState.joystickRadius).toFixed(1)}px, ${(vy * touchState.joystickRadius).toFixed(1)}px)`;
            };

            const findTouchById = (touchList, id) => {
                for (let i = 0; i < touchList.length; i++) {
                    if (touchList[i].identifier === id) return touchList[i];
                }
                return null;
            };

            joystick.addEventListener('touchstart', (event) => {
                event.preventDefault();
                updateJoystickCenter();
                const touch = event.changedTouches[0];
                touchState.movePointerId = touch.identifier;
                updateJoystickFromTouch(touch);
            }, { passive: false });

            joystick.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (touchState.movePointerId === null) return;
                const touch = findTouchById(event.touches, touchState.movePointerId);
                if (touch) updateJoystickFromTouch(touch);
            }, { passive: false });

            const endJoystickTouch = (event) => {
                if (touchState.movePointerId === null) return;
                const ended = findTouchById(event.changedTouches, touchState.movePointerId);
                if (!ended) return;
                touchState.movePointerId = null;
                resetJoystick();
            };

            joystick.addEventListener('touchend', endJoystickTouch, { passive: false });
            joystick.addEventListener('touchcancel', endJoystickTouch, { passive: false });

            lookZone.addEventListener('touchstart', (event) => {
                event.preventDefault();
                const touch = event.changedTouches[0];
                touchState.lookPointerId = touch.identifier;
                touchState.lookLast.set(touch.clientX, touch.clientY);

                if (!touchState.hasStartedLooking && touchHint) {
                    touchState.hasStartedLooking = true;
                    window.setTimeout(() => {
                        touchHint.classList.add('fade-out');
                    }, 5000);
                }
            }, { passive: false });

            lookZone.addEventListener('touchmove', (event) => {
                event.preventDefault();
                if (touchState.lookPointerId === null) return;
                const touch = findTouchById(event.touches, touchState.lookPointerId);
                if (!touch) return;

                const movementX = touch.clientX - touchState.lookLast.x;
                const movementY = touch.clientY - touchState.lookLast.y;
                touchState.lookLast.set(touch.clientX, touch.clientY);

                _euler.setFromQuaternion(camera.quaternion);
                _euler.y -= movementX * 0.004;
                _euler.x -= movementY * 0.004;
                _euler.x = Math.max(_PI_2 - controls.maxPolarAngle, Math.min(_PI_2 - controls.minPolarAngle, _euler.x));
                camera.quaternion.setFromEuler(_euler);
            }, { passive: false });

            const endLookTouch = (event) => {
                if (touchState.lookPointerId === null) return;
                const ended = findTouchById(event.changedTouches, touchState.lookPointerId);
                if (!ended) return;
                touchState.lookPointerId = null;
            };

            lookZone.addEventListener('touchend', endLookTouch, { passive: false });
            lookZone.addEventListener('touchcancel', endLookTouch, { passive: false });

            touchUi.addEventListener('touchstart', (event) => {
                if (event.touches.length >= 2) {
                    controls.isLocked = false;
                    document.getElementById('instructions').style.display = 'flex';
                    if (touchUiEl) touchUiEl.style.display = 'none';
                    resetJoystick();
                    touchState.lookPointerId = null;
                }
            }, { passive: true });

            window.addEventListener('resize', updateJoystickCenter);
            resetJoystick();
        }

        // --- Procedural Textures ---

        function createMandalaTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            const cx = 512;
            const cy = 512;

            // Background
            ctx.fillStyle = '#2A1A0A';
            ctx.fillRect(0, 0, 1024, 1024);

            // Outer Gold Ring - MATCHING VIBRANT GOLD COLOR
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 20;
            ctx.beginPath();
            ctx.arc(cx, cy, 480, 0, Math.PI * 2);
            ctx.stroke();

            // Inner Ming Blue Ring (Texture Ring)
            ctx.strokeStyle = '#102E4A';
            ctx.lineWidth = 40;
            ctx.beginPath();
            ctx.arc(cx, cy, 350, 0, Math.PI * 2);
            ctx.stroke();

            // Radial Beams - MATCHING VIBRANT GOLD COLOR
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 10;
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(cx + Math.cos(angle) * 100, cy + Math.sin(angle) * 100);
                ctx.lineTo(cx + Math.cos(angle) * 480, cy + Math.sin(angle) * 480);
                ctx.stroke();
            }

            // Central Sun - MATCHING VIBRANT GOLD COLOR
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(cx, cy, 100, 0, Math.PI * 2);
            ctx.fill();

            const tex = new THREE.CanvasTexture(canvas);

            // Async load Logo, scale it down to fit center, color it Red
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = function() {
                const tCanvas = document.createElement('canvas');
                tCanvas.width = img.width;
                tCanvas.height = img.height;
                const tCtx = tCanvas.getContext('2d');

                tCtx.drawImage(img, 0, 0);
                tCtx.globalCompositeOperation = 'source-in';
                tCtx.fillStyle = '#9B1B30'; // Imperial Red for Logo
                tCtx.fillRect(0, 0, tCanvas.width, tCanvas.height);

                // Draw centered, scaled down to fit inside radius 100
                const size = 140;
                ctx.drawImage(tCanvas, cx - size/2, cy - size/2, size, size);
                tex.needsUpdate = true;
            };
            img.src = LOGO_URL;

            return tex;
        }

        function createBloodwoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#4a0404';
            ctx.fillRect(0, 0, 1024, 1024);

            for (let i = 0; i < 50000; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#5c0a0a' : '#330000';
                const x = Math.random() * 1024;
                const y = Math.random() * 1024;
                const l = Math.random() * 50 + 10;
                ctx.fillRect(x, y, l, 2);
            }

            const brickW = 200;
            const brickH = 50;
            ctx.strokeStyle = '#220000';
            ctx.lineWidth = 3;

            for (let y = 0; y < 1024; y += brickH) {
                const offset = (y / brickH) % 2 === 0 ? 0 : brickW / 2;
                for (let x = -brickW; x < 1024; x += brickW) {
                    ctx.strokeRect(x + offset, y, brickW, brickH);
                }
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(4, 4);
            return tex;
        }

        function createCeramicTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#888888';
            ctx.fillRect(0, 0, 512, 512);

            for (let i = 0; i < 10000; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#999999' : '#777777';
                ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
            }

            ctx.strokeStyle = '#555555';
            ctx.lineWidth = 12;
            ctx.strokeRect(0, 0, 512, 512);

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        // --- Environment Building ---

        function buildRoom() {
            const bloodwoodTex = createBloodwoodTexture();
            const ceramicTex = createCeramicTexture();

            const ceramicTexH = ceramicTex.clone();
            ceramicTexH.repeat.set(10, 2);
            ceramicTexH.needsUpdate = true;

            const ceramicTexV = ceramicTex.clone();
            ceramicTexV.repeat.set(2, 7);
            ceramicTexV.needsUpdate = true;

            const woodFloorMat = new THREE.MeshStandardMaterial({
                map: bloodwoodTex,
                roughness: 0.78,
                metalness: 0.03,
                color: 0x8a6666
            });

            const ceramicMatH = new THREE.MeshStandardMaterial({
                map: ceramicTexH,
                roughness: 0.1,
                metalness: 0.2,
                color: 0xaaaaaa
            });

            const ceramicMatV = new THREE.MeshStandardMaterial({
                map: ceramicTexV,
                roughness: 0.1,
                metalness: 0.2,
                color: 0xaaaaaa
            });

            const wallMat = new THREE.MeshStandardMaterial({
                color: COL_WALL,
                roughness: 0.8
            });

            // Vibrant Ming Gold Material (General)
            const goldMat = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                roughness: 0.3,
                metalness: 0.4,
                emissive: 0xaa8800,
                emissiveIntensity: 0.2
            });

            // Pedestal baseboards now match the wall/pillar Ming gold trim.
            const spotlightGoldMat = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                roughness: 0.3,
                metalness: 0.4,
                emissive: 0xaa8800,
                emissiveIntensity: 0.2
            });

            // Floor
            const woodGeo = new THREE.PlaneGeometry(34, 34);
            const woodFloor = new THREE.Mesh(woodGeo, woodFloorMat);
            woodFloor.rotation.x = - Math.PI / 2;
            woodFloor.receiveShadow = true;
            scene.add(woodFloor);

            const ceramicGeoH = new THREE.PlaneGeometry(50, 8);
            const ceramicGeoV = new THREE.PlaneGeometry(8, 34);

            const cNorth = new THREE.Mesh(ceramicGeoH, ceramicMatH);
            cNorth.rotation.x = - Math.PI / 2;
            cNorth.position.set(0, 0, -21);
            cNorth.receiveShadow = true;
            scene.add(cNorth);

            const cSouth = new THREE.Mesh(ceramicGeoH, ceramicMatH);
            cSouth.rotation.x = - Math.PI / 2;
            cSouth.position.set(0, 0, 21);
            cSouth.receiveShadow = true;
            scene.add(cSouth);

            const cEast = new THREE.Mesh(ceramicGeoV, ceramicMatV);
            cEast.rotation.x = - Math.PI / 2;
            cEast.position.set(21, 0, 0);
            cEast.receiveShadow = true;
            scene.add(cEast);

            const cWest = new THREE.Mesh(ceramicGeoV, ceramicMatV);
            cWest.rotation.x = - Math.PI / 2;
            cWest.position.set(-21, 0, 0);
            cWest.receiveShadow = true;
            scene.add(cWest);

            // Ceiling
            buildCeiling();

            // Walls
            const wallH = new THREE.BoxGeometry(ROOM_WIDTH, ROOM_HEIGHT, WALL_THICKNESS);
            const wallV = new THREE.BoxGeometry(WALL_THICKNESS, ROOM_HEIGHT, ROOM_DEPTH);

            const northWall = new THREE.Mesh(wallH, wallMat);
            northWall.position.set(0, ROOM_HEIGHT/2, -ROOM_DEPTH/2 - WALL_THICKNESS/2);
            northWall.receiveShadow = true;
            scene.add(northWall);
            collidableObjects.push({
                min: { x: -ROOM_WIDTH/2, z: -ROOM_DEPTH/2 },
                max: { x: ROOM_WIDTH/2, z: -ROOM_DEPTH/2 + WALL_THICKNESS }
            });

            const southWall = new THREE.Mesh(wallH, wallMat);
            southWall.position.set(0, ROOM_HEIGHT/2, ROOM_DEPTH/2 + WALL_THICKNESS/2);
            southWall.receiveShadow = true;
            scene.add(southWall);

            const eastWall = new THREE.Mesh(wallV, wallMat);
            eastWall.position.set(ROOM_WIDTH/2 + WALL_THICKNESS/2, ROOM_HEIGHT/2, 0);
            eastWall.receiveShadow = true;
            scene.add(eastWall);

            const westWall = new THREE.Mesh(wallV, wallMat);
            westWall.position.set(-ROOM_WIDTH/2 - WALL_THICKNESS/2, ROOM_HEIGHT/2, 0);
            westWall.receiveShadow = true;
            scene.add(westWall);

            // Baseboards
            const bbHeight = 0.8;
            const bbDepth = 0.3;
            const bbGeoH = new THREE.BoxGeometry(ROOM_WIDTH - 0.1, bbHeight, bbDepth);
            const bbGeoV = new THREE.BoxGeometry(bbDepth, bbHeight, ROOM_DEPTH - 0.1);

            const bbNorth = new THREE.Mesh(bbGeoH, goldMat);
            bbNorth.position.set(0, bbHeight/2, -ROOM_DEPTH/2 + bbDepth/2);
            scene.add(bbNorth);

            const bbSouth = new THREE.Mesh(bbGeoH, goldMat);
            bbSouth.position.set(0, bbHeight/2, ROOM_DEPTH/2 - bbDepth/2);
            scene.add(bbSouth);

            const bbEast = new THREE.Mesh(bbGeoV, goldMat);
            bbEast.position.set(ROOM_WIDTH/2 - bbDepth/2, bbHeight/2, 0);
            scene.add(bbEast);

            const bbWest = new THREE.Mesh(bbGeoV, goldMat);
            bbWest.position.set(-ROOM_WIDTH/2 + bbDepth/2, bbHeight/2, 0);
            scene.add(bbWest);

            // Columns & Exhibits
            buildColumns(goldMat);
            buildExhibitsAndArt(goldMat, spotlightGoldMat);
        }

        function buildCeiling() {
            const ceilingGroup = new THREE.Group();

            const mainMat = new THREE.MeshStandardMaterial({ color: 0x221100, roughness: 0.9 });
            const backingGeo = new THREE.PlaneGeometry(ROOM_WIDTH, ROOM_DEPTH);
            const backing = new THREE.Mesh(backingGeo, mainMat);
            backing.rotation.x = Math.PI / 2;
            backing.position.y = ROOM_HEIGHT + 1.0;
            ceilingGroup.add(backing);

            const beamMat = new THREE.MeshStandardMaterial({ color: COL_DARK_WOOD, roughness: 0.6 });
            const beamThickness = 0.8;
            const beamDepth = 0.8;

            for (let z = -ROOM_DEPTH/2 + 5; z < ROOM_DEPTH/2; z += 5) {
                const beamGeo = new THREE.BoxGeometry(ROOM_WIDTH, beamDepth, beamThickness);
                const beam = new THREE.Mesh(beamGeo, beamMat);
                beam.position.set(0, ROOM_HEIGHT, z);
                ceilingGroup.add(beam);
            }

            for (let x = -ROOM_WIDTH/2 + 5; x < ROOM_WIDTH/2; x += 5) {
                const beamGeo = new THREE.BoxGeometry(beamThickness, beamDepth, ROOM_DEPTH);
                const beam = new THREE.Mesh(beamGeo, beamMat);
                beam.position.set(x, ROOM_HEIGHT, 0);
                ceilingGroup.add(beam);
            }

            const mandalaTexture = createMandalaTexture();
            const mandalaMat = new THREE.MeshStandardMaterial({
                map: mandalaTexture,
                roughness: 0.3,
                metalness: 0.4,
                side: THREE.FrontSide
            });

            const mandalaY = ROOM_HEIGHT - 0.5;
            const mandalaGeo = new THREE.CylinderGeometry(8, 8, 0.4, 32);
            const mandala = new THREE.Mesh(mandalaGeo, beamMat);
            mandala.position.set(0, mandalaY, 0);
            ceilingGroup.add(mandala);

            const featureGeo = new THREE.CylinderGeometry(7.5, 7.5, 0.5, 64);
            const feature = new THREE.Mesh(featureGeo, new THREE.MeshStandardMaterial({ color: COL_IMPERIAL_RED }));
            feature.position.set(0, mandalaY - 0.1, 0);
            ceilingGroup.add(feature);

            const artGeo = new THREE.CircleGeometry(7, 64);
            const artMesh = new THREE.Mesh(artGeo, mandalaMat);
            artMesh.rotation.x = Math.PI / 2;
            artMesh.rotation.z = Math.PI ;
            artMesh.position.set(0, mandalaY - 0.36, 0);
            ceilingGroup.add(artMesh);

            scene.add(ceilingGroup);
        }

        function buildColumns(goldMat) {
            const colRadius = 1.0;
            const colHeight = ROOM_HEIGHT;
            const colMat = new THREE.MeshStandardMaterial({
                color: COL_IMPERIAL_RED,
                roughness: 0.15,
                metalness: 0.1
            });

            const colGeo = new THREE.CylinderGeometry(colRadius, colRadius, colHeight, 32);
            const baseGeo = new THREE.CylinderGeometry(colRadius * 1.3, colRadius * 1.3, 1.2, 32);

            const positions = [
                {x: -20, z: -20},
                {x: 20, z: -20},
                {x: -20, z: 20},
                {x: 20, z: 20}
            ];

            positions.forEach(pos => {
                const col = new THREE.Mesh(colGeo, colMat);
                col.position.set(pos.x, colHeight/2, pos.z);
                col.castShadow = true;
                scene.add(col);

                const base = new THREE.Mesh(baseGeo, goldMat);
                base.position.set(pos.x, 0.6, pos.z);
                base.castShadow = true;
                scene.add(base);

                const top = new THREE.Mesh(baseGeo, goldMat);
                top.position.set(pos.x, colHeight - 0.6, pos.z);
                scene.add(top);

                collidableObjects.push({
                    type: 'cylinder',
                    x: pos.x, z: pos.z, radius: colRadius * 1.3
                });
            });
        }

        function buildLighting() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambient);

            const hemiLight = new THREE.HemisphereLight(0xffeeb1, 0x555555, 0.7);
            scene.add(hemiLight);

            const mainLight = new THREE.PointLight(0xffaa55, 1.8, 90);
            mainLight.position.set(0, 17.5, 0);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = qualitySettings.mainShadowMapSize;
            mainLight.shadow.mapSize.height = qualitySettings.mainShadowMapSize;
            scene.add(mainLight);
        }

        function initDevToolkit() {
            devToolkitEl = document.getElementById('dev-toolkit');
            const artifactSelect = document.getElementById('dev-artifact-select');
            artifactSelect.addEventListener('change', (event) => {
                devToolkitState.selectedId = event.target.value;
                syncInputsFromSelectedArtifact();
            });

            const inputIds = [
                'dev-pos-x', 'dev-pos-y', 'dev-pos-z',
                'dev-scale-x', 'dev-scale-y', 'dev-scale-z',
                'dev-rot-x', 'dev-rot-y', 'dev-rot-z'
            ];

            const scaleUniformInput = document.getElementById('dev-scale-uniform');

            inputIds.forEach((id) => {
                const input = document.getElementById(id);
                input.addEventListener('input', applyToolkitValuesToSelectedArtifact);
                input.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    const currentValue = Number.parseFloat(input.value);
                    const fallback = Number.isFinite(currentValue) ? currentValue : 0;
                    const step = Number.parseFloat(input.step) || 1;
                    const direction = event.deltaY < 0 ? 1 : -1;
                    const nextValue = fallback + (direction * step);
                    input.value = nextValue.toFixed(3);

                    if (
                        scaleUniformInput.checked &&
                        ['dev-scale-x', 'dev-scale-y', 'dev-scale-z'].includes(id)
                    ) {
                        ['dev-scale-x', 'dev-scale-y', 'dev-scale-z'].forEach((scaleId) => {
                            document.getElementById(scaleId).value = input.value;
                        });
                    }

                    applyToolkitValuesToSelectedArtifact();
                }, { passive: false });
            });
        }

        function toggleDevToolkit() {
            if (!devToolkitEl) return;
            devToolkitState.isVisible = !devToolkitState.isVisible;
            devToolkitEl.style.display = devToolkitState.isVisible ? 'block' : 'none';

            if (devToolkitState.isVisible) {
                suppressInstructionsOverlay = true;
                document.getElementById('instructions').style.display = 'none';
                controls.unlock();
                moveForward = false;
                moveBackward = false;
                moveLeft = false;
                moveRight = false;
                syncInputsFromSelectedArtifact();
            } else {
                suppressInstructionsOverlay = false;
                document.getElementById('instructions').style.display = 'flex';
            }
        }

        function syncInputsFromSelectedArtifact() {
            const artifact = artifactRegistry[devToolkitState.selectedId];
            if (!artifact) return;

            devToolkitState.isUpdatingInputs = true;
            document.getElementById('dev-pos-x').value = artifact.position.x.toFixed(3);
            document.getElementById('dev-pos-y').value = artifact.position.y.toFixed(3);
            document.getElementById('dev-pos-z').value = artifact.position.z.toFixed(3);

            document.getElementById('dev-scale-x').value = artifact.scale.x.toFixed(3);
            document.getElementById('dev-scale-y').value = artifact.scale.y.toFixed(3);
            document.getElementById('dev-scale-z').value = artifact.scale.z.toFixed(3);

            document.getElementById('dev-rot-x').value = artifact.rotation.x.toFixed(3);
            document.getElementById('dev-rot-y').value = artifact.rotation.y.toFixed(3);
            document.getElementById('dev-rot-z').value = artifact.rotation.z.toFixed(3);
            devToolkitState.isUpdatingInputs = false;
        }

        function applyToolkitValuesToSelectedArtifact() {
            if (devToolkitState.isUpdatingInputs) return;
            const artifact = artifactRegistry[devToolkitState.selectedId];
            if (!artifact) return;

            const scaleUniformInput = document.getElementById('dev-scale-uniform');

            const read = (id, fallback) => {
                const value = Number.parseFloat(document.getElementById(id).value);
                return Number.isFinite(value) ? value : fallback;
            };

            artifact.position.set(
                read('dev-pos-x', artifact.position.x),
                read('dev-pos-y', artifact.position.y),
                read('dev-pos-z', artifact.position.z)
            );

            const nextScaleX = Math.max(0.01, read('dev-scale-x', artifact.scale.x));
            const nextScaleY = Math.max(0.01, read('dev-scale-y', artifact.scale.y));
            const nextScaleZ = Math.max(0.01, read('dev-scale-z', artifact.scale.z));
            if (scaleUniformInput.checked) {
                artifact.scale.set(nextScaleX, nextScaleX, nextScaleX);
                document.getElementById('dev-scale-y').value = nextScaleX.toFixed(3);
                document.getElementById('dev-scale-z').value = nextScaleX.toFixed(3);
            } else {
                artifact.scale.set(nextScaleX, nextScaleY, nextScaleZ);
            }

            artifact.rotation.set(
                read('dev-rot-x', artifact.rotation.x),
                read('dev-rot-y', artifact.rotation.y),
                read('dev-rot-z', artifact.rotation.z)
            );

            artifact.userData.baseRotation = {
                x: artifact.rotation.x,
                y: artifact.rotation.y,
                z: artifact.rotation.z
            };

            const spinEntry = rotatingArtifacts.find((entry) => entry.mesh === artifact);
            if (spinEntry) {
                spinEntry.baseRotation = artifact.userData.baseRotation;
            }
        }

        function buildExhibitsAndArt(goldMat, spotlightGoldMat) {
            const textureLoader = new THREE.TextureLoader(loadingManager);
            textureLoader.setCrossOrigin('anonymous');
            const gltfLoader = new GLTFLoader(loadingManager);

            // --- 1. Logos ---
            textureLoader.load(LOGO_URL, (tex) => {
                const logoGeo = new THREE.PlaneGeometry(8, 8);
                const logoMat = new THREE.MeshBasicMaterial({
                    map: tex,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });

                const offsets = [
                    { pos: new THREE.Vector3(0, 10, -ROOM_DEPTH/2 + 0.1), rot: new THREE.Vector3(0, 0, 0) },
                    { pos: new THREE.Vector3(0, 10, ROOM_DEPTH/2 - 0.1), rot: new THREE.Vector3(0, Math.PI, 0) },
                    { pos: new THREE.Vector3(ROOM_WIDTH/2 - 0.1, 10, 0), rot: new THREE.Vector3(0, -Math.PI/2, 0) },
                    { pos: new THREE.Vector3(-ROOM_WIDTH/2 + 0.1, 10, 0), rot: new THREE.Vector3(0, Math.PI/2, 0) }
                ];

                offsets.forEach(off => {
                    const mesh = new THREE.Mesh(logoGeo, logoMat);
                    mesh.position.copy(off.pos);
                    mesh.rotation.set(off.rot.x, off.rot.y, off.rot.z);
                    scene.add(mesh);
                });
            });

            // --- 2. Central Exhibits ---
            const pedestalGeo = new THREE.BoxGeometry(2, 1.2, 2);
            const pedestalMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.2, metalness: 0.3 });
            const pedBaseboardGeo = new THREE.BoxGeometry(2.2, 0.2, 2.2);

            const exhibitConfs = [
                { id: 'north', pos: new THREE.Vector3(0, 0, -15), shape: 'dodecahedron', wallNormal: new THREE.Vector3(0, 0, 1), paintings: [] },
                { id: 'south', pos: new THREE.Vector3(0, 0, 15), shape: 'torus', wallNormal: new THREE.Vector3(0, 0, -1), paintings: [2, 3, 0] },
                { id: 'east', pos: new THREE.Vector3(15, 0, 0), shape: 'icosahedron', wallNormal: new THREE.Vector3(-1, 0, 0), paintings: [4, 5, 1] },
                { id: 'west', pos: new THREE.Vector3(-15, 0, 0), shape: 'octahedron', wallNormal: new THREE.Vector3(1, 0, 0), paintings: [6, 7, 8] }
            ];

            const glbFiles = {
                north: '3D Models/Statue.glb',
                south: '3D Models/Pot.glb',
                east: '3D Models/Golden.glb',
                west: '3D Models/Bowl 1.glb'
            };

            const artifactTransformConfig = {
                north: {
                    // Statue default rotation X.
                    orientation: new THREE.Euler(0, 0, 0),
                    spinAxis: 'y'
                },
                south: {
                    // Pot default rotation X.
                    orientation: new THREE.Euler(Math.PI / 2, 0, 0),
                    spinAxis: 'y'
                },
                east: {
                    // Golden: keep upright and spin on a horizontal axis.
                    orientation: new THREE.Euler(0, 0, 0),
                    spinAxis: 'x'
                },
                west: {
                    // Bowl: keep upright and spin on a horizontal axis.
                    orientation: new THREE.Euler(0, 0, 0),
                    spinAxis: 'x'
                }
            };

            const artifactDefaultOverrides = {
                north: { positionY: 3.000, scaleUniform: 3.600, rotationX: 0 },
                south: { positionY: 2.19, scaleUniform: 3, rotationX: 3.142 },
                east: { positionY: 1.95, scaleUniform: 1.5 },
                west: { positionY: 1.89, scaleUniform: 2 }
            };

            const artifactLightTuning = {
                north: { midY: 3.000, sideDistance: 3.7, sideTargetOffset: 1.2, sideIntensity: 1.9, centerOffsetY: 0.9, centerIntensity: 4.2 },
                south: { midY: 2.19, sideDistance: 3.4, sideTargetOffset: 1.1, sideIntensity: 1.8, centerOffsetY: 0.9, centerIntensity: 4.0 },
                east: { midY: 2.05, sideDistance: 3.8, sideTargetOffset: 1.35, sideIntensity: 2.75, centerOffsetY: 0.6, centerIntensity: 6.2 },
                west: { midY: 1.98, sideDistance: 3.8, sideTargetOffset: 1.35, sideIntensity: 2.75, centerOffsetY: 0.6, centerIntensity: 6.2 }
            };

            const alignArtifactToPedestal = (object, targetPosition, targetHeight = 1.2, pedestalTopY = 2.2) => {
                const box = new THREE.Box3().setFromObject(object);
                const size = new THREE.Vector3();
                box.getSize(size);
                if (size.y > 0) {
                    const scale = targetHeight / size.y;
                    object.scale.setScalar(scale);
                }

                object.position.set(targetPosition.x, pedestalTopY, targetPosition.z);
                object.updateMatrixWorld(true);

                const worldBox = new THREE.Box3().setFromObject(object);
                const center = worldBox.getCenter(new THREE.Vector3());
                object.position.x += targetPosition.x - center.x;
                object.position.z += targetPosition.z - center.z;

                object.updateMatrixWorld(true);
                const alignedBox = new THREE.Box3().setFromObject(object);
                const yOffset = pedestalTopY - alignedBox.min.y;
                object.position.y += yOffset;
            };

            exhibitConfs.forEach((conf) => {
                // Pedestal
                const pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
                pedestal.position.set(conf.pos.x, 0.6, conf.pos.z);
                pedestal.castShadow = true;
                pedestal.receiveShadow = true;
                scene.add(pedestal);

                // Pedestal Baseboard using spotlightGoldMat
                const pedBaseboard = new THREE.Mesh(pedBaseboardGeo, spotlightGoldMat);
                pedBaseboard.position.set(conf.pos.x, 0.1, conf.pos.z);
                pedBaseboard.receiveShadow = true;
                scene.add(pedBaseboard);

                collidableObjects.push({ type: 'box', x: conf.pos.x, z: conf.pos.z, size: 2.5 });

                const artifactTarget = new THREE.Object3D();
                artifactTarget.position.set(conf.pos.x, 2.2, conf.pos.z);
                scene.add(artifactTarget);

                const glbFile = glbFiles[conf.id];
                if (glbFile) {
                    gltfLoader.load(glbFile, (gltf) => {
                        const artifact = gltf.scene;
                        const transform = artifactTransformConfig[conf.id] || { orientation: new THREE.Euler(0, 0, 0), spinAxis: 'y' };
                        artifact.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                if (child.material && child.material.isMeshStandardMaterial) {
                                    child.material.needsUpdate = true;
                                }
                            }
                        });
                        alignArtifactToPedestal(artifact, conf.pos, 1.3, 2.2);
                        const lookTarget = new THREE.Vector3(0, artifact.position.y, 0);
                        artifact.lookAt(lookTarget);
                        artifact.rotation.x += transform.orientation.x;
                        artifact.rotation.y += transform.orientation.y;
                        artifact.rotation.z += transform.orientation.z;
                        alignArtifactToPedestal(artifact, conf.pos, 1.3, 2.2);

                        const overrides = artifactDefaultOverrides[conf.id];
                        if (overrides) {
                            if (Number.isFinite(overrides.scaleUniform)) {
                                artifact.scale.setScalar(overrides.scaleUniform);
                            }
                            if (Number.isFinite(overrides.positionY)) {
                                artifact.position.y = overrides.positionY;
                            }
                            if (Number.isFinite(overrides.rotationX)) {
                                artifact.rotation.x = overrides.rotationX;
                            }
                        }

                        artifact.userData.baseRotation = {
                            x: artifact.rotation.x,
                            y: artifact.rotation.y,
                            z: artifact.rotation.z
                        };
                        artifactRegistry[conf.id] = artifact;
                        artifact.userData.artifactId = conf.id;
                        artifactTarget.position.copy(artifact.position);
                        scene.add(artifact);
                        rotatingArtifacts.push({
                            mesh: artifact,
                            baseRotation: artifact.userData.baseRotation,
                            axis: transform.spinAxis,
                            speed: 0.2
                        });

                        if (devToolkitState.isVisible && devToolkitState.selectedId === conf.id) {
                            syncInputsFromSelectedArtifact();
                        }
                    });
                }

                const artifactLight = new THREE.PointLight(0xffd699, 2.8, 7);
                artifactLight.position.set(conf.pos.x, 3.5, conf.pos.z);
                scene.add(artifactLight);

                const fillLight = new THREE.PointLight(0xffffff, 1.1, 9);
                fillLight.position.set(conf.pos.x + 1.5, 2.8, conf.pos.z + 1.5);
                scene.add(fillLight);

                const lightTuning = artifactLightTuning[conf.id] || { midY: 2.2, sideDistance: 3.2, sideTargetOffset: 1.0, sideIntensity: 1.6, centerOffsetY: 0.8, centerIntensity: 3.8 };
                const radialDir = conf.pos.clone().setY(0).normalize();
                const sideAxis = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), radialDir).normalize();
                const sideLightRange = 12;
                const sideLightOffsets = [
                    sideAxis.clone().multiplyScalar(lightTuning.sideDistance),
                    sideAxis.clone().multiplyScalar(-lightTuning.sideDistance)
                ];

                sideLightOffsets.forEach((offset) => {
                    const sideLight = new THREE.SpotLight(0xfff1dc, lightTuning.sideIntensity, sideLightRange);
                    sideLight.position.set(conf.pos.x + offset.x, lightTuning.midY, conf.pos.z + offset.z);
                    sideLight.angle = Math.PI / 4;
                    sideLight.penumbra = 0.58;
                    sideLight.decay = 1.1;

                    const inward = offset.clone().normalize().multiplyScalar(-lightTuning.sideTargetOffset);
                    const sideTarget = new THREE.Object3D();
                    sideTarget.position.set(
                        conf.pos.x + inward.x,
                        lightTuning.midY,
                        conf.pos.z + inward.z
                    );
                    sideLight.target = sideTarget;
                    scene.add(sideTarget);
                    scene.add(sideLight);
                });

                // Add two inward key lights aimed at the artifact center of gravity area
                // so darker assets (golden + bowl) are fully readable.
                const keyLightDistance = 4.8;
                const keyLightY = lightTuning.midY + lightTuning.centerOffsetY;
                const keyLightPositions = [
                    conf.pos.clone().add(radialDir.clone().multiplyScalar(keyLightDistance)).setY(keyLightY),
                    conf.pos.clone().add(radialDir.clone().multiplyScalar(-keyLightDistance)).setY(keyLightY)
                ];

                keyLightPositions.forEach((lightPos) => {
                    const keyLight = new THREE.SpotLight(0xfff6de, lightTuning.centerIntensity, 20);
                    keyLight.position.copy(lightPos);
                    keyLight.angle = Math.PI / 5;
                    keyLight.penumbra = 0.5;
                    keyLight.decay = 1.1;

                    const centerTarget = new THREE.Object3D();
                    centerTarget.position.set(conf.pos.x, lightTuning.midY, conf.pos.z);
                    keyLight.target = centerTarget;
                    scene.add(centerTarget);
                    scene.add(keyLight);
                });

                const spotLight = new THREE.SpotLight(0xfff4d0, 13.5);
                spotLight.position.set(conf.pos.x + 1.2, 8.5, conf.pos.z + 1.2);
                spotLight.angle = Math.PI / 7;
                spotLight.penumbra = 0.62;
                spotLight.decay = 1.2;
                spotLight.distance = 24;
                spotLight.target = artifactTarget;
                spotLight.castShadow = qualitySettings.enableArtifactSpotShadows;
                spotLight.shadow.mapSize.width = qualitySettings.artifactShadowMapSize;
                spotLight.shadow.mapSize.height = qualitySettings.artifactShadowMapSize;
                scene.add(spotLight);
                scene.add(spotLight.target);

                if (conf.id === 'north') {
                    const wallPos = conf.pos.clone().add(conf.wallNormal.clone().multiplyScalar(-10 + 0.1));
                    wallPos.y = 5.0;
                    loadPainting(LONG_PAINTING_URL, wallPos, conf.wallNormal, 5.0, textureLoader);
                }

                const height = 4.5;
                const up = new THREE.Vector3(0, 1, 0);
                const right = new THREE.Vector3().crossVectors(conf.wallNormal, up).normalize();

                conf.paintings.forEach((pIndex, i) => {
                    const pData = PAINTINGS[pIndex];
                    let offset = 0;

                    if (conf.paintings.length === 2) {
                        offset = (i === 0 ? -1 : 1) * 8;
                    } else if (conf.paintings.length === 3) {
                        if (i === 0) offset = -12;
                        if (i === 1) offset = 0;
                        if (i === 2) offset = 12;
                    }

                    const wallPos = conf.pos.clone().add(conf.wallNormal.clone().multiplyScalar(-10 + 0.1));
                    const paintPos = wallPos.clone().add(right.clone().multiplyScalar(offset));
                    paintPos.y = height;

                    loadPainting(pData.url, paintPos, conf.wallNormal, 3.5, textureLoader);
                });
            });
        }

        function loadPainting(url, position, normal, forcedHeight = 3.5, loader) {
            const textureLoader = loader || new THREE.TextureLoader();

            textureLoader.load(url, (tex) => {
                const aspect = tex.image.width / tex.image.height;
                const baseHeight = forcedHeight;
                const baseWidth = baseHeight * aspect;

                const frameGeo = new THREE.BoxGeometry(baseWidth + 0.4, baseHeight + 0.4, 0.2);
                const frameMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.6 });
                const frame = new THREE.Mesh(frameGeo, frameMat);

                const canvasGeo = new THREE.PlaneGeometry(baseWidth, baseHeight);
                const canvasMat = new THREE.MeshStandardMaterial({
                    map: tex,
                    roughness: 0.6,
                    metalness: 0.1
                });
                const canvas = new THREE.Mesh(canvasGeo, canvasMat);
                canvas.position.z = 0.11;

                frame.add(canvas);

                frame.position.copy(position);
                frame.lookAt(frame.position.clone().add(normal));

                scene.add(frame);

                const pLight = new THREE.PointLight(0xffffff, 0.4, 15);
                pLight.position.copy(position).add(normal.clone().multiplyScalar(2));
                scene.add(pLight);
            });
        }

        function checkCollision(nextPos) {
            const halfW = ROOM_WIDTH / 2 - WALL_THICKNESS - 0.5;
            const halfD = ROOM_DEPTH / 2 - WALL_THICKNESS - 0.5;

            if (nextPos.x < -halfW || nextPos.x > halfW) return true;
            if (nextPos.z < -halfD || nextPos.z > halfD) return true;

            for (let obj of collidableObjects) {
                if (obj.type === 'cylinder') {
                    const dx = nextPos.x - obj.x;
                    const dz = nextPos.z - obj.z;
                    const minDist = obj.radius + 0.5;
                    if ((dx * dx + dz * dz) < (minDist * minDist)) return true;
                } else if (obj.type === 'box') {
                    const dx = nextPos.x - obj.x;
                    const dz = nextPos.z - obj.z;
                    const minDist = obj.size/2 + 0.5;
                    if ((dx * dx + dz * dz) < (minDist * minDist)) return true;
                }
            }
            return false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, qualitySettings.maxPixelRatio));
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            let delta = (time - prevTime) / 1000;
            delta = Math.min(delta, 0.1);

            if (controls.isLocked === true) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= GRAVITY * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (touchState.isMobileOrTablet && touchState.movePointerId !== null) {
                    direction.x = touchState.joystickVector.x;
                    direction.z = -touchState.joystickVector.y;
                }

                let speed = isSprinting ? SPRINT_SPEED : PLAYER_SPEED;
                if (isCrouching) speed = CROUCH_SPEED;

                if (moveForward || moveBackward) velocity.z -= direction.z * speed * 10.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * 10.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                controls.getObject().position.y += ( velocity.y * delta );

                const targetHeight = isCrouching ? CROUCH_HEIGHT : STAND_HEIGHT;

                if ( controls.getObject().position.y < targetHeight ) {
                    velocity.y = Math.max(0, velocity.y);
                    controls.getObject().position.y = targetHeight;
                    canJump = true;
                }

                const pos = controls.getObject().position;
                if (checkCollision(pos)) {
                    controls.moveRight(velocity.x * delta);
                    controls.moveForward(velocity.z * delta);
                    velocity.x = 0;
                    velocity.z = 0;
                }
            }

            if (artifactSpinEnabled) {
                const rotationTime = time * 0.001;
                rotatingArtifacts.forEach((entry, idx) => {
                    const mesh = entry.mesh || entry;
                    const axis = entry.axis ?? 'y';
                    const baseRotation = entry.baseRotation ?? mesh.userData.baseRotation ?? {
                        x: mesh.rotation.x,
                        y: mesh.rotation.y,
                        z: mesh.rotation.z
                    };
                    const speed = entry.speed ?? 0.15 + (idx % 2) * 0.05;

                    mesh.rotation.x = baseRotation.x;
                    mesh.rotation.y = baseRotation.y;
                    mesh.rotation.z = baseRotation.z;
                    mesh.rotation[axis] = baseRotation[axis] + rotationTime * speed;
                });
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
